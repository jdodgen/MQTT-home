package client;
# Copyright2021 by James E Dodgen Jr.  All rights reserved.
use Net::OpenSSH;
use Carp;
use Data::Dumper;
use db;
use strict;
use html;
use cfg;
use tools;
use QueueManager;
use http_processor;
use Text::CSV;

use filterPrint;
use constant DBG => 1;
my $fp = filterPrint->new();

use constant SLEEPTIME => 10;

sub task
{
    my $WorkerBeeQueue = QueueManager::WorkerBeeQueue();
    my $EvaluateQueue = QueueManager::EvaluateQueue();
    my $XbeeSendQueue = QueueManager::XbeeSendQueue();
    my $dt = db::open(cfg::DBNAME);
    my $csv = Text::CSV->new();
    while (1)
    {
        my $cfg = tools::get_config($dt);
        my $pan_id = $cfg->{pan_id};
        my $hex_pan_id = sprintf("%x", $pan_id);
        DBG&&$fp->prt("starting SSH connections [$hex_pan_id]");
        my $ssh_send = Net::OpenSSH->new(cfg::FTP_SITE,
            port => cfg::FTP_PORT,
            user => cfg::FTP_USER,
            password => cfg::FTP_PASSWORD,
            master_opts => [-o => "StrictHostKeyChecking=no"]);
        if ($ssh_send->error) # open failed
        {
            $WorkerBeeQueue->enqueue({request => "LOG", fmt => "Client SSH new error [%s]", parms => [$ssh_send->error]});
            last;
        }
        else
        {
            my $ssh_read = Net::OpenSSH->new(cfg::FTP_SITE,
                port => cfg::FTP_PORT,
                user => cfg::FTP_USER,
                password => cfg::FTP_PASSWORD,
                master_opts => [-o => "StrictHostKeyChecking=no"]);
            if ($ssh_read->error) # open failed
            {
                $WorkerBeeQueue->enqueue({request => "LOG", fmt => "Client SSH new error [%s]", parms => [$ssh_read->error]});
                last;
            }

            else
            {
                my ($inxx, $out, $pid) = $ssh_read->open2("perl -I . aaclient_sender.pl $hex_pan_id");
                if ($ssh_send->error) # open2 failed
                {
                    $WorkerBeeQueue->enqueue({request => "LOG", fmt => "Client open2 reader error [%s]", parms => [$ssh_read->error]});
                    last;
                }
                my ($in, $outxx, $pid) = $ssh_send->open2("perl -I . aaclient_reader.pl $hex_pan_id");
                if ($ssh_send->error) # open2 failed
                {
                    $WorkerBeeQueue->enqueue({request => "LOG", fmt => "Client open2 sender error [%s]", parms => [$ssh_send->error]});
                    last;
                }
                while (1)
                {
                    my $request = readline($out);
                    if ($ssh_send->error or !$request)
                    {
                        printf "client:  read error [%s]\n", $ssh_send->error;
                        last;
                    }
                    else
                    {
                        chomp $request;
                        #DBG&&$fp->prt("read [$request]");
                        my $status = $csv->parse ($request);
                        my ($cmd, @fields) = $csv->fields();
                         #my ($cmd, $data) = split(/\|/, $request);
                        DBG&&$fp->prt("split [%s][%s]", $cmd, join ',',@fields);
                        if ($cmd eq 'keepalive')
                        {
                            # just ignore
                        }
                        elsif ($cmd eq 'error')
                        {
                            $WorkerBeeQueue->enqueue({request => "LOG", fmt => "Client recieved error [%s]", parms => [@fields]});
                        }
                        elsif ($cmd eq 'toggle')
                        {
                            my ($device, $value) = @fields;
                            #my ($device, $value) = split(/\~/, $data);
                            DBG&&$fp->prt("toggle [%s][%s]", $device, $value);
                            use constant NOT_WEMO => 0;
                            http_processor::do_extern_device($dt, $device, $value, NOT_WEMO, $EvaluateQueue, $XbeeSendQueue);
                            print $in "ack\n";
                        }
                        elsif ($cmd eq 'devices')
                        {
                            # query devices with names and send them in a list
                            my $devices = external_devices_csv($dt, $csv);
                            my $send = "devices,".$devices."\n";
                            printf $in $send;
                            printf"[%s]\n",$send;
                        }
                        else
                        {
                            printf $in "Huh?,?\n";
                        }
                    }
                }

            }
        }
        DBG&&$fp->prt("SSH broke, now sleeping and retrying]");
        sleep(SLEEPTIME);
    }
   ;
}

sub external_devices_csv
{
    my ($dt, $csv) = @_;

    my $metric_units = tools::get_config($dt)->{metric_units};
    my @fields = qw(current logic port_name value desc);
    my @devices = $dt->tmpl_loop_query(
        <<EOF, @fields);
        SELECT devices.current, port_types.logic,devices.port_name, devices.raw_value, device_types.desc
        FROM devices
        JOIN wireless_devices ON wireless_devices.ah = devices.ah
           AND wireless_devices.al = devices.al
           AND wireless_devices.part_nbr = port_types.part_nbr
           AND devices.port = port_types.port
        JOIN device_types ON wireless_devices.part_nbr = device_types.part_nbr
        JOIN port_types   ON device_types.part_nbr = port_types.part_nbr
        WHERE devices.port_name IS NOT NULL

EOF
    my $last;    ##  OR port_types.type IS NULL
    # print Dumper $wireless_devices[2];
    my $dev = '';
    foreach my $x (@devices)
    {
        $x->{port_on} = "ON";
        $x->{port_off} = "OFF";
        if ($x->{logic} eq "BINARY")
        {
            if ($x->{current})
            {
                 $x->{value} = $x->{current} eq 'ON'?'ON':'OFF';
            }
            else
            {
                 $x->{value} = "Unknown"; #$x->{default_state}?'ON':'OFF';
            }
        }
        if ($x->{logic} eq "VALVE")
        {
            $x->{port_on} = "OPEN";
            $x->{port_off} = "CLOSE";
            if ($x->{current})
            {
                 $x->{value} = $x->{current} eq 'ON'?'Should be Open':'Should be Closed';
            }
            else
            {
                 $x->{value} = $x->{default_state}?'Should be Open':'Should be Closed';
            }

        }
        elsif ($x->{logic} eq "SW1")
        {
            if (defined $x->{value} && $x->{value} == 0)
            {
               $x->{value} = "OPEN";
            }
            else
            {
               $x->{value} = "CLOSED";
            }
        }
        elsif ($x->{logic} eq "SW0")
        {

            if (defined $x->{value} && $x->{value} == 1)
            {
               $x->{value} = "OPEN";
            }
            else
            {
               $x->{value} = "CLOSED";
            }
        }
        elsif ($x->{logic} eq "SIG1")
        {

            if (defined $x->{value} && $x->{value} == 1)
            {
               $x->{value} = "TRUE";
            }
            else
            {
               $x->{value} = "FALSE";
            }
        }
        elsif ($x->{logic} eq "HIGH")
        {

            if (defined $x->{value} && $x->{value} == 1)
            {
               $x->{value} = "ON";
            }
            else
            {
               $x->{value} = "OFF";
            }
        }
        elsif ($x->{logic} eq "LOW")
        {

            if (defined $x->{value} && $x->{value} == 0)
            {
               $x->{value} = "ON";
            }
            else
            {
               $x->{value} = "OFF";
            }
        }
        elsif ($x->{logic} eq "SIG0")
        {

            if (defined $x->{value} && $x->{value} == 0)
            {
               $x->{value} = "TRUE";
            }
            else
            {
               $x->{value} = "FALSE";
            }
        }
        elsif ($x->{logic} eq "OPEN")
        {

            if (defined $x->{value} && $x->{value} == 0)
            {
               $x->{value} = "OPEN";
            }
            else
            {
               $x->{supress_row} = 1;
               $x->{value} = "";
            }
        }
        elsif ($x->{logic} eq "CLOSED")
        {

            if (defined $x->{value} && $x->{value} == 0)
            {
               $x->{value} = "CLOSED";
            }
            else
            {
               $x->{supress_row} = 1;
               $x->{value} = "";
            }
        }
        elsif ($x->{logic} eq "MOMENTARY1")
        {

            $x->{value} = "";
        }

        elsif ($x->{logic} eq "MOMENTARY0")
        {

            $x->{value} = "";
        }
        delete $x->{logic};
        delete $x->{current};

        $csv->combine(clean($x->{desc}),clean($x->{port_name}),clean($x->{value}),clean($x->{port_on}),clean($x->{port_off}));
        $dev .= $csv->string()."|";

        #$dev .=  sprintf("%s^%s^%s^%s^%s~", clean($x->{desc}),clean($x->{port_name}),clean($x->{value}),clean($x->{port_on}),clean($x->{port_off}));
    }
    printf"[%s]\n", $dev;
    return ($dev);
}

sub clean
{
    my ($s) = @_;
    $s =~ tr/|\n/  /;
    return tools::trim($s);
}

#print "running test\n";
#my $dt = db::open(cfg::DBNAME);
#my $devices = external_devices_csv($dt);
#print $devices;
#my @lines = split("~",$devices);
#foreach my $l (@lines)
#{
    #print "$l\n";
#}

#task();

1;
